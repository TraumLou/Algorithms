# 1. Two Sum 两数之和

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

我：暴力解法：直接两两比对，计算后直接输出即可，时间复杂度O(n^2)，空间复杂度O(1)，只是这个排名太低了
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        for (int i = 0; i < nums.size(); ++i) {
            for (int j = i+1; j < nums.size(); ++j) {
                if (nums[i] + nums[j] == target) {
                    result.push_back(i);
                    result.push_back(j);
                    break;
                }
            }
        }
        
        return result;
    }
};
```

官方题解1：两遍哈希：先把数组存储成map，然后一个一个遍历这个数组，并判断map中是否存在另外一个元素，如果存在则返回

官方题解2：一遍哈希：在把数组存储成map的过程中，每读到一个新的数字，即查询map中另外一个元素是否存在

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        map<int, int> mp;
        mp.insert(pair(nums[0], 0));
        map<int, int>::iterator it;
        for (int i = 1; i < nums.size(); ++i) {
            it = mp.find(target - nums[i]);
            if (mp.find(target - nums[i]) != mp.end()) {
                result.push_back(it->second);
                result.push_back(i);
            } else {
                mp.insert(pair(nums[i], i));
            }
        }
        
        return result;
    }
};
```

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        unordered_map<int, int> mp;
        mp.insert(pair(nums[0], 0));
        for (int i = 1; i < nums.size(); ++i) {
            if (mp.find(target - nums[i]) != mp.end()) {
                result.push_back(mp[target - nums[i]]);
                result.push_back(i);
            } else {
                mp.insert(pair(nums[i], i));
            }
        }
        return result;
    }
};
```

答案区的高分代码：
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> m;
        for(int i=0;i<nums.size();i++)
        {
            if(m.find(target-nums[i]) != m.end())       //m中存在对应的键值
                return {m[target-nums[i]] , i};         //因为i为较大的元素，此时添加进去的键值都还小于i，所以i在后面
            m[nums[i]]=i;       //向map中添加元素
        }
        return {};
    }
};
```